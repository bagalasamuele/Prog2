# Lezione 17
## La classe astratta ricorsiva degli alberi di ricerca

Lezione 17. La definizione ricorsiva di albero binario. Vediamo ora un altro esempio di classe astratta e ricorsiva: la classe degli alberi di ricerca. Si tratta di una classe importante per definire una struttura dati che sia dinamica (non ha una dimensione prefissata, cresce o diminuisce a seconda delle esigenze) e che consenta nel caso medio un accesso veloce (in tempo logaritmico) ai dati. Come esempio vedremo alberi di ricerca di interi, che rappresentano insiemi finiti di interi, ma con poco più lavoro potremmo definire una classe generica, di alberi di ricerca su un tipo di dati T qualsiasi.

Iniziamo con la definizione ricorsiva degli alberi binari di interi. Gli alberi binari di interi sono alberi vuoti, rappresentati con oggetti di tipo `Leaf`, oppure hanno una radice, costituita da un intero, e un sottoalbero sinistro e uno destro. Le radici dei sottoalberi sono dette i nodi dell'albero, le radici del sottoalbero sinistro e destro (quando esistono) sono dette i figli sinistri e destri. Il percorso dalla radice a un nodo è detto un ramo dell'albero.

Un albero binario di interi è di ricerca se la radice è maggiore di ogni nodo nel sottoalbero sinistro, e minore di ogni nodo nel sottoalbero destro, e lo stesso vale per ogni nodo dell'albero. In particolare, non ci sono nodi ripetuti. Il termine "di ricerca" si riferisce al fatto che per questi alberi la ricerca di un elemento nell'albero è particolarmente efficiente: il tempo richiesto è in media proporzionale al logaritmo del numero dei nodi. Vedrete questi argomenti nel corso di Algoritmi. Come esempio, ecco un albero di nodi 1,2,3.


Si tratta di un albero di ricerca perché l’unico nodo che si trova a sinistra, 1, è minore della radice 2, che è minore dell’unico nodo 3 a destra. Tutto ciò che conta in un albero sono i collegamenti tra i nodi. Ecco due modi di disegnare lo stesso albero, con nodi 0,2,4,6,7. Nel primo disegno i sottoalberi sono disposti dall’alto in basso, nel secondo disegno da sinistra a destra. Anche in questo caso si tratta di un albero di ricerca. Nel primo disegno, i sottoalberi non vuoti sono evidenziati con dei rettangoli.



Possiamo definire gli alberi di ricerca per ogni tipo di dati per cui abbiamo definito un ordine (totale). In questa lezione ci occupiamo di definire una classe astratta Tree per gli alberi di ricerca di interi. La costruzione è simile a quella delle liste astratte viste nella Lezione 17: la classe astratta e ricorsiva Tree ha due sottoclassi concrete, Leaf (alberi vuoti) e Branch (alberi non vuoti), gli elementi di Branch possono contenere elementi di Leaf e altri elementi di Branch.
Accenniamo anche che ci sono esempi di classi astratte ricorsive con molte sottoclassi concrete: per esempio la classe delle istruzioni di un linguaggio di programmazione si può rappresentare come una classe astratta ricorsiva con molte sottoclassi concrete, la classe degli If, la classe dei While, dei For, delle assegnazioni e così via. Tuttavia, questi esempi fanno parte di corsi successivi, come Linguaggi Formali, e non li vedremo in questo corso.
Ritorniamo ora alla classe Tree. Gli elementi di Tree hanno la caratteristica di essere dinamici (cambiano di dimensione a seconda della necessità). Come abbiamo anticipato, inoltre, consentono di effettuare ricerca, inserimento e cancellazione di un nodo in tempo

   
proporzionale al logaritmo del numero dei nodi (quindi velocemente). Questo, purché siano mantenuti bilanciati (cioè con parte sinistra e destra approssivamente uguali). Nel corso di ProgII non ci occupiamo di questo secondo aspetto, che sarà trattato nel corso di Algoritmi.
Come metodi della classe Tree definiamo: (i) boolean empty() per decidere se un albero è vuoto, (ii) int max() per calcolare il nodo massimo di un albero, (iii) boolean contains(int x) per decidere se un albero contiene il nodo x, e infine (iv) Tree insert(int x) e (v) Tree remove(int x) per aggiungere/rimuovere un nodo x. Le modifiche devono preservare il fatto che ogni albero è un albero di ricerca.
Infine aggiungiamo (vi) un metodo String toString() per “disegnare” un albero con soli caratteri ASCII, metodo che non spieghiamo.
Nota 1. Come rimuovere un nodo. Non è semplice rimuovere un nodo x da un albero di ricerca e ottenere ancora un albero di ricerca. Consideriamo il caso in cui il nodo da eliminare è la radice dell’albero e entrambi i suoi sottoalberi non sono vuoti. Prendiamo l’albero con radice 3, figli sinistro e destri 1 e 4, e con 2 figlio destro di 1. Ecco un disegno fatto con soli caratteri ascii.



Se eliminiamo la radice 3, scomponiamo l’albero nel sottoalbero sinistro, di nodi 1,2, e nel sottoalbero destro con il solo nodo 4. Dobbiamo riconnettere i due alberi, con una radice scelta in modo tale da ottenere un albero di ricerca. A tal fine, rimpiazzeremo il nodo 3 con il massimo nodo del sottoalbero sinistro (il nodo 2 in questo caso). In questo modo evitiamo di disconnettere l’albero e inseriamo una radice maggiore o uguale di ogni nodo a sinistra e minore di ogni nodo a destra. Per avere un albero di ricerca, dobbiamo ancora evitare di ripetere il nodo 2 nella radice e nel sottoalbero sinistro. È
sufficiente eliminare il nodo 2 dal sottoalbero sinistro: dato il sottoalbero sinistro è un albero più piccolo dell’albero di partenza, questa è una definizione corretta di un algoritmo ricorsivo per rimuovere un nodo da un albero.
Nota 2. Cosa succede quando modifichiamo un albero. In questa implementazione, quando inseriamo o cancelliamo elementi scegliamo di modificare l’albero originale. Questo significa che se scriviamo per esempio t.remove(x), l’indirizzo dell’albero t può cambiare, e adesso la variabile t può contenere un indirizzo errato. Per ovviare a questo scriveremo t=t.remove(x), per rimuovere un elemento x e contemporaneamente aggiornare l’indirizzo di t. Se ce ne dimentichiamo, generiamo errori a catena nel nostro programma.